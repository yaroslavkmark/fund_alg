### 1 Вопрос
**Алгоритмическая сложность. «О большое». Худший\лучший\средний случай.**

**Алгоритмическая сложность** - это мера количества ресурсов (времени и памяти), необходимых для выполнения алгоритма в зависимости от размера входных данных.

``` O(f) = nf ``` - определение O (простое)

```f(x)=O(g(x)), если существуют положительные константы C и x0 такие, что ∣f(x)∣≤C⋅∣g(x)∣для всех x>x0 (f растет быстрее чем g)``` - определение из мат. анализа.

- **Худший случай (Worst case)**: Описывает максимальное время выполнения алгоритма для любого набора входных данных заданного размера. Это наиболее часто используемая оценка, так как она гарантирует, что алгоритм будет работать не медленнее определенного времени.
    
- **Лучший случай (Best case)**: Описывает минимальное время выполнения алгоритма для любого набора входных данных заданного размера. Эта оценка обычно не очень полезна, так как маловероятно, что алгоритм будет работать именно в этом случае.
    
- **Средний случай (Average case)**: Описывает ожидаемое время выполнения алгоритма для всех возможных наборов входных данных заданного размера. Для вычисления среднего случая необходимо знать распределение вероятностей входных данных, что не всегда возможно.

**Пример:**
- **Линейный поиск**:
    - Худший случай: O(n) - элемент находится в конце списка.
    - Лучший случай: O(1) - элемент находится в начале списка.
    - Средний случай: O(n/2) - элемент находится в середине списка.

### 2 Вопрос
**Типы данных в языке C. Операции над переменными стандартных типов и их особенности. Операция приведения типов. Арифметические, логические и бинарные операции. Операция быстрого возведения в степень, её алгоритмическая сложность**

- **Целочисленные типы:**
    - `char` 
    - `short`
    - `int`
    - `long`
    - `long long`
- **Типы с плавающей точкой:**
    - `float`
    - `double`
    - `long double`
- **Указатели:**
    - Типы указателей, например, `int*`, `char*` и так далее
- **Массивы:**
    - Массивы элементов одного типа, например, `int arr[10]`.
- **Структуры:**
    - Составные типы данных, состоящие из нескольких полей, например, `struct Point { int x; int y; }`.
- **Объединения:**
    - Типы данных, которые могут хранить значения разных типов в одном и том же месте в памяти.

*Размер правильно узнавать через функцию **sizeof(<тип данных>)***

**Операции над переменными стандартных типов:**

- **Арифметические операции:**
    - Сложение (`+`), вычитание (`-`), умножение (`*`), деление (`/`), остаток от деления (`%`).
    - Особенности:
        - Деление целых чисел выполняется нацело, например, `5 / 2` равно `2`.
        - Деление чисел с плавающей точкой выполняется с дробной частью, например, `5.0 / 2.0` равно `2.5`.
- **Логические операции:**
    - Логическое И (`&&`), логическое ИЛИ (`||`), логическое НЕ (`!`).
    - Особенности:
        - Логические операции выполняются над значениями, которые могут быть преобразованы в `_Bool` (0 - ложь, не 0 - истина).
- **Бинарные операции:**
    - Побитовое И (`&`), побитовое ИЛИ (`|`), побитовое НЕ (`~`), побитовое исключающее ИЛИ (`^`), сдвиг влево (`<<`), сдвиг вправо (`>>`).
    - Особенности:
        - Бинарные операции выполняются над отдельными битами чисел.
- **Операции сравнения:**
    - Равно (`==`), не равно (`!=`), больше (`>`), меньше (`<`), больше или равно (`>=`), меньше или равно (`<=`).
    - Особенности:
        - Результат операции сравнения - целочисленное значение (1 или 0).

**Операция приведения типов:**
- **Приведение типов** - это явное преобразование значения одного типа данных в другой тип.
- Синтаксис: `(тип) выражение`.
- Примеры:
    - `int a = 5; float b = (float) a;` (преобразование целого числа в число с плавающей точкой).
    - `float c = 3.14; int d = (int) c;` (преобразование числа с плавающей точкой в целое число, дробная часть отбрасывается).

**Бинарное возведение в степень**

```cpp
int binpow(int a, int n) {
    int res = 1;
    while (n != 0) {
        if (n & 1)
            res = res * a;
        a = a * a;
        n >>= 1;
    }
    return res;
}
```
![photo_2024-11-26_21-04-50 (2).jpg](images%2Fphoto_2024-11-26_21-04-50%20%282%29.jpg)
### Вопрос 3
**Форматы представления целых и вещественных чисел в памяти компьютера.**


**Представление знаковых чисел**

|   Число   |   char   | unsigned char |
| :-------: | :------: | :-----------: |
|     1     |  000001  |    000001     |
| -1 \| 255 | 11111111 |   11111111    |
*Определение отрицательного числа:*
	-x:= x', такой что x + x' = 0
	-x: ~|x| + 1 - то, как кодируется отрицательное число.
	Для целых чисел есть арифметические, битовые и логические операции.	

**Представление вещественных чисел**
![photo_2024-11-26_21-04-50.jpg](images%2Fphoto_2024-11-26_21-04-50.jpg)
### Вопрос 4
**Условный оператор в языке C. Логические операции и выражения. Тернарный оператор в языке C**

**Условный оператор** (или оператор ветвления) в языке C используется для выполнения различных блоков кода в зависимости от условия. Основными условными операторами в C являются `if`, `else` и `else if`.

``` c
if (условие) {
    // Блок кода, выполняемый, если условие истинно
} else if (другое_условие) {
    // Блок кода, выполняемый, если другое_условие истинно
} else {
    // Блок кода, выполняемый, если все предыдущие условия ложны
}
```
**Логические операции** в языке C используются для объединения или инвертирования логических условий. Основные логические операции в C:
- **Логическое И (`&&`):** Возвращает `1`, если оба операнда истинны.
- **Логическое ИЛИ (`||`):** Возвращает `1`, если хотя бы один из операндов истинен.
- **Логическое НЕ (`!`):** Инвертирует значение операнда (возвращает `1`, если операнд ложен, и наоборот).

**Тернарный оператор** (или условный оператор) в языке C предоставляет сокращенный способ записи условного выражения. Он имеет следующий синтаксис:


```
условие ? выражение1 : выражение2;
```
**Принцип работы:**
- Если `условие` истинно, то вычисляется и возвращается `выражение1`.
- Если `условие` ложно, то вычисляется и возвращается `выражение2`.

### Вопрос 5
**Операторы цикла в языке C. Управление выполнением тела операторов цикла.**

Операторы цикла в языке C используются для многократного выполнения блока кода. Основные операторы цикла в C:
1. **`for`**
2. **`while`**
3. **`do-while`**

```c
for (инициализация; условие; обновление) {
    // Тело цикла
}
while (условие) {
    // Тело цикла
}
do {
    // Тело цикла
} while (условие);
```

В языке C есть 2 ключевых слова, которые позволяют управлять выполнением тела цикла:
1. **`break`**
2. **`continue`**

*break* - выводит из цикла
*continue* - переводит к следующей итерации

### Вопрос 6
**Тип указателя. Арифметика указателей. Массивы и строки. Операции над строками и их непосредственная реализация.**

**Указатель** - это переменная, которая хранит адрес другой переменной в памяти. Указатели используются для динамического выделения памяти, передачи аргументов в функции по ссылке, работы с массивами и строками, а также для реализации сложных структур данных, таких как связные списки и деревья.

`тип *имя_указателя;`
``` c
int *ptr;  // Указатель на переменную типа int
char *str; // Указатель на переменную типа char

int x = 10;
*ptr = &x;  // ptr указывает на переменную x
```

**Арифметика указателей** позволяет выполнять операции сложения, вычитания, инкремента и декремента над указателями. При этом учитывается размер типа данных, на который указывает указатель.

``` c
int arr[5] = {1, 2, 3, 4, 5};
int *ptr = arr;  // ptr указывает на первый элемент массива

// Инкремент указателя
ptr++;  // ptr теперь указывает на второй элемент массива

// Вычитание указателей
int *ptr2 = &arr[3];
int diff = ptr2 - ptr;  // diff будет равен 2 (количество элементов между ptr и ptr2)
```

**Массив** - это набор элементов одного типа, расположенных в памяти последовательно. Доступ к элементам массива осуществляется по индексу.

`cтип имя_массива[размер];`
```c
int arr[5];  // Массив из 5 элементов типа int
char str[] = "Hello";  // Строка "Hello"
```

```c
void str_copy(char *dest, const char *src) {
    while ((*dest++ = *src++));
}

int str_len(const char *str) {
    int len = 0;
    while (*str++) {
        len++;
    }
    return len;
}

int str_cmp(const char *str1, const char *str2) {
    while (*str1 && (*str1 == *str2)) {
        str1++;
        str2++;
    }
    return *str1 - *str2;
}

char *str_chr(const char *str, int ch) {
    while (*str && *str != ch) {
        str++;
    }
    return (*str == ch) ? (char *)str : NULL;
}
```


### Вопрос 7
**Конвертация чисел из строки и в строку. Схема Горнера и обратная схеме Горнера для преобразования строкового представления числа, записанного в заданной системе счисления, в значение целочисленного типа и наоборот; алгоритмическая сложность и реализация на языке C.**

**Схема Горнера** - это эффективный алгоритм для вычисления значения многочлена в точке. Она также может быть использована для преобразования строкового представления числа в заданной системе счисления в целочисленное значение. **Алгоритмическая сложность:** O(n), где n - длина строки.

**Обратная схема Горнера** -  это алгоритм для преобразования целочисленного значения в строковое представление в заданной системе счисления. **Алгоритмическая сложность:** O(log⁡b(n)), где n - значение числа, b - основание системы счисления.

```c
int gorner(char str[], int base){
	int res = 0;
	char *ps = str;
	ps = str - 1;
	while(*++ps)
		res = res* base + (isalpha(*ps))? *ps - 'A' + 10: *ps-'0';
	return res;
}

void gorner_obr(int n, int base){
	int r;
	char buf[BUFSIZ], *pb = buf+BUFSIZ-1;
	*pb--=0;
	while(n){
		*pb--=((r=n%base) > 9)? r - 10 + 'A': r + '0';
		n /= base;
	}
	printf("%s\n", pb + 1);
}
```


### Вопрос 8
**Файловый ввод/вывод в языке C. Методы чтения и записи файлов. Циклы чтения файлов с обработкой символа конца файла и без неё. Типизированные и нетипизированные файлы. Структура FILE. Форматируемый ввод/вывод. Методы выделения лексем из входного строкового потока. Принцип границы и функция strtok.**


**Файловый ввод/вывод** в языке C осуществляется с помощью библиотеки стандартных функций, таких как `fopen`, `fclose`, `fread`, `fwrite`, `fprintf`, `fscanf`, `fgets`, `fputs` и других. Для работы с файлами используется структура `FILE`, которая представляет собой структуру с дескриптором файла.

**1. Открытие и закрытие файла:**
- **`fopen`**: Открывает файл и возвращает указатель на структуру `FILE`.
- **`fclose`**: Закрывает файл, связанный с указателем на `FILE`.
**Пример:**
```
c
FILE *file = fopen("example.txt", "r");  // Открытие файла для чтения
if (file == NULL) {
    perror("Ошибка открытия файла");
    return 1;
}

// Работа с файлом

fclose(file);  // Закрытие файла
```

**2. Чтение и запись файлов:**
- **`fread`**: Читает данные из файла в буфер.
- **`fwrite`**: Записывает данные из буфера в файл.
- **`fprintf`**: Записывает форматированный вывод в файл.
- **`fscanf`**: Читает форматированный ввод из файла.
- **`fgets`**: Читает строку из файла.
- **`fputs`**: Записывает строку в файл.

```c
// Чтение строки из файла
char buffer[100];
if (fgets(buffer, sizeof(buffer), file) != NULL) {
    printf("Прочитанная строка: %s", buffer);
}

// Запись строки в файл
FILE *output = fopen("output.txt", "w");
if (output != NULL) {
    fputs("Привет, мир!", output);
    fclose(output);
}
```

***Типизированные и нетипизированные файлы***
- **Типизированные файлы**: Файлы, в которых данные хранятся в виде записей фиксированной длины, состоящих из полей различных типов.
- **Нетипизированные файлы**: Файлы, в которых данные хранятся в виде последовательности байтов без определенной структуры.
**Структура `FILE`** - это абстрактный тип данных, который содержит дескриптор файла. Она содержит информацию о состоянии файла, такую как позиция указателя чтения/записи, флаги ошибок и конца файла, а также буфер для оптимизации операций ввода/вывода.

***strtok***
**Функция `strtok`** разбивает строку на лексемы (подстроки), используя заданные разделители.
**Пример:**
```c
#include <stdio.h>
#include <string.h>

int main() {
    char str[] = "Привет, мир! Как дела?";
    char *token = strtok(str, " ,!");
    while (token != NULL) {
        printf("%s\n", token);
        token = strtok(NULL, " ,!");
    }
    return 0;
}
```
**Принцип границы:**

**Принцип границы** заключается в том, что лексемы разделяются символами-разделителями. Функция `strtok` заменяет первый символ-разделитель после каждой лексемы на нулевой символ (`'\0'`), чтобы разделить строку на подстроки.


### Вопрос 9
**Функции. Способы передачи аргументов в функции. Возврат значений из функции через возвращаемое значение, через параметры функции. Глобальные и локальные переменные. Область видимости переменных. Модификатор static.**

***Способы передачи аргументов в функции***
В языке C аргументы могут передаваться в функции двумя основными способами:
1. **По значению (by value):**
    - Аргументы передаются в функцию как копии значений.
    - Любые изменения значений аргументов внутри функции не влияют на оригинальные переменные.
**Пример:**
```c
void increment(int x) {
    x++;
}

int main() {
    int a = 5;
    increment(a);
    printf("%d\n", a);  // Вывод: 5
    return 0;
}
```

2. **По указателю (by pointer):**
    - Аргументы передаются в функцию как указатели на переменные.
    - Любые изменения значений через указатели внутри функции влияют на оригинальные переменные.
**Пример:**
```c

void increment(int *x) {
    (*x)++;
}

int main() {
    int a = 5;
    increment(&a);
    printf("%d\n", a);  // Вывод: 6
    return 0;
}
```

***Возврат значений из функции***
Функции в языке C могут возвращать значения двумя способами:
1. **Через возвращаемое значение:**
    - Функция возвращает значение с помощью оператора `return`.
    - Тип возвращаемого значения указывается при объявлении функции.
**Пример:**
```c
int add(int a, int b) {
    return a + b;
}

int main() {
    int result = add(3, 4);
    printf("%d\n", result);  // Вывод: 7
    return 0;
}
```
2. **Через параметры функции:**
    - Функция изменяет значения переданных ей параметров-указателей.
    - Это позволяет "возвращать" несколько значений из функции.
**Пример:**
```c

void swap(int *a, int *b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

int main() {
    int x = 3, y = 4;
    swap(&x, &y);
    printf("x = %d, y = %d\n", x, y);  // Вывод: x = 4, y = 3
    return 0;
}
```
***Глобальные и локальные переменные***
**Глобальные переменные** объявляются вне всех функций и доступны во всех функциях программы.
**Пример:**

```c
int globalVar = 10;

void printGlobal() {
    printf("Global variable: %d\n", globalVar);
}

int main() {
    printGlobal();  // Вывод: Global variable: 10
    return 0;
}
```
**Локальные переменные** объявляются внутри функций и доступны только в пределах этой функции.
**Пример:**

```c
void printLocal() {
    int localVar = 20;
    printf("Local variable: %d\n", localVar);
}

int main() {
    printLocal();  // Вывод: Local variable: 20
    // printf("%d\n", localVar);  // Ошибка: localVar не определена в этой области видимости
    return 0;
}
```

***Область видимости переменных***

**Область видимости переменных** определяет, где в программе переменная может быть использована.

- **Локальная область видимости**: Переменные, объявленные внутри функции или блока кода, доступны только в пределах этой функции или блока.
- **Глобальная область видимости**: Переменные, объявленные вне всех функций, доступны во всех функциях программы.

***Модификатор `static`***

**Модификатор `static`** используется для изменения области видимости и времени жизни переменных.
1. **Статические локальные переменные:**
    - Область видимости: внутри функции, в которой они объявлены.
    - Время жизни: в течение всего выполнения программы.
    - Значение сохраняется между вызовами функции.

**Пример:**
```c
void incrementStatic() {
    static int count = 0;
    count++;
    printf("Count: %d\n", count);
}

int main() {
    incrementStatic();  // Вывод: Count: 1
    incrementStatic();  // Вывод: Count: 2
    incrementStatic();  // Вывод: Count: 3
    return 0;
}
```


### Вопрос 10
**Функции с переменным числом аргументов. Типы данных и основные макросы для работы со списком аргументов переменной длины. Указатели на функции. Массив указателей на функции. Функция atexit.**

**Функции с переменным числом аргументов** (variadic functions) - это функции, которые могут принимать различное количество аргументов. В языке C для работы с такими функциями используется библиотека `<stdarg.h>`.

```c
#include <stdio.h>
#include <stdarg.h>

// Функция, которая принимает переменное число аргументов типа int и возвращает их сумму
int sum(int count, ...) {
    va_list args;
    int total = 0;

    // Инициализация списка аргументов
    va_start(args, count);

    // Перебор аргументов
    for (int i = 0; i < count; i++) {
        total += va_arg(args, int);
    }

    // Завершение работы со списком аргументов
    va_end(args);

    return total;
}

int main() {
    int result = sum(3, 1, 2, 3);
    printf("Сумма: %d\n", result);  // Вывод: Сумма: 6
    return 0;
}
```

***Типы данных и основные макросы для работы со списком аргументов переменной длины***
- **`va_list`**: Тип данных, используемый для хранения списка аргументов.
- **`va_start(va_list ap, last_arg)`**: Макрос для инициализации списка аргументов. `ap` - переменная типа `va_list`, `last_arg` - последний известный аргумент функции.
- **`va_arg(va_list ap, type)`**: Макрос для получения следующего аргумента из списка. `ap` - переменная типа `va_list`, `type` - тип ожидаемого аргумента.
- **`va_end(va_list ap)`**: Макрос для завершения работы со списком аргументов.

***Указатели на функции***

**Указатель на функцию** - это переменная, которая хранит адрес функции. Указатели на функции позволяют передавать функции в качестве аргументов другим функциям, создавать массивы функций и динамически выбирать, какую функцию вызывать.
**Массив указателей на функции** - это массив, элементами которого являются указатели на функции. Это позволяет хранить и вызывать несколько функций через один массив.

`<тип данных> <*имя функции> (<тип, тип...>)`


***atexit***
**Функция `atexit`** используется для регистрации функций, которые будут вызваны при завершении программы. Это позволяет выполнить очистку ресурсов или сохранить данные перед завершением работы программы.
```c
#include <stdio.h>
#include <stdlib.h>

// Функция, которая будет вызвана при завершении программы
void cleanup() {
    printf("Выполнение очистки перед завершением программы\n");
}

int main() {
    // Регистрация функции cleanup для вызова при завершении программы
    atexit(cleanup);

    printf("Основная работа программы\n");

    return 0;
}
```